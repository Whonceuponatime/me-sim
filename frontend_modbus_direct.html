<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Direct MODBUS TCP Engine Monitor</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background-color: #1a1a1a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            border: 2px solid #00ff00;
            padding: 20px;
            margin-bottom: 20px;
        }
        .gauge-container {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
        }
        .gauge {
            border: 1px solid #00ff00;
            padding: 20px;
            text-align: center;
            min-width: 150px;
        }
        .value {
            font-size: 2em;
            font-weight: bold;
            color: #00ffff;
        }
        .label {
            font-size: 0.8em;
            margin-top: 10px;
        }
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        button {
            background-color: #003300;
            color: #00ff00;
            border: 2px solid #00ff00;
            padding: 15px 30px;
            font-size: 1.2em;
            cursor: pointer;
            margin: 0 10px;
        }
        button:hover {
            background-color: #006600;
        }
        .status {
            border: 1px solid #00ff00;
            padding: 15px;
            margin: 20px 0;
        }
        .log {
            border: 1px solid #00ff00;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            background-color: #000;
            font-size: 0.9em;
        }
        .running { color: #00ff00; }
        .stopped { color: #ff0000; }
        .warning { color: #ffff00; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üö¢ DIRECT MODBUS TCP ENGINE MONITOR üö¢</h1>
            <p>This frontend generates actual MODBUS TCP packets</p>
            <p>Monitor with Wireshark: <code>tcp.port == 5020 or modbus</code></p>
        </div>

        <div class="status">
            <h3>CONNECTION STATUS</h3>
            <div id="connection-status">Disconnected</div>
            <div>Target: <span id="target-host">192.168.0.25:5020</span></div>
            <div>Protocol: <span style="color: #00ffff;">MODBUS TCP</span></div>
        </div>

        <div class="gauge-container">
            <div class="gauge">
                <div class="value" id="rpm">0</div>
                <div class="label">RPM</div>
            </div>
            <div class="gauge">
                <div class="value" id="temp">0</div>
                <div class="label">TEMPERATURE (¬∞C)</div>
            </div>
            <div class="gauge">
                <div class="value" id="fuel">0.0</div>
                <div class="label">FUEL FLOW (t/h)</div>
            </div>
            <div class="gauge">
                <div class="value" id="load">0</div>
                <div class="label">LOAD (%)</div>
            </div>
        </div>

        <div class="controls">
            <button onclick="startEngine()" id="start-btn">START ENGINE</button>
            <button onclick="stopEngine()" id="stop-btn">EMERGENCY STOP</button>
            <button onclick="togglePolling()" id="poll-btn">START POLLING</button>
        </div>

        <div class="status">
            <h3>ENGINE STATUS: <span id="engine-status" class="stopped">STOPPED</span></h3>
            <div>Last Update: <span id="last-update">Never</span></div>
            <div>Packets Sent: <span id="packet-count">0</span></div>
        </div>

        <div class="log">
            <h4>MODBUS TCP COMMUNICATION LOG:</h4>
            <div id="log-content"></div>
        </div>
    </div>

    <script>
        // MODBUS TCP configuration
        const MODBUS_HOST = '192.168.0.25';
        const MODBUS_PORT = 5020;
        
        // Register addresses
        const REGISTERS = {
            STATUS: 0,
            RPM: 1,
            TEMP: 2,
            FUEL_FLOW: 3,
            LOAD: 4
        };

        let packetCount = 0;
        let pollingInterval = null;
        let isPolling = false;

        // Update target display
        document.getElementById('target-host').textContent = `${MODBUS_HOST}:${MODBUS_PORT}`;

        function log(message) {
            const logContent = document.getElementById('log-content');
            const timestamp = new Date().toLocaleTimeString();
            logContent.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            logContent.scrollTop = logContent.scrollHeight;
        }

        async function sendModbusRequest(functionCode, register, value = null) {
            packetCount++;
            document.getElementById('packet-count').textContent = packetCount;

            try {
                // Use a simple HTTP-to-MODBUS proxy approach for demonstration
                // In a real scenario, you'd use a proper MODBUS TCP library
                
                const url = `http://${MODBUS_HOST}:8000/api/modbus-direct`;
                const payload = {
                    host: MODBUS_HOST,
                    port: MODBUS_PORT,
                    function_code: functionCode,
                    register: register,
                    value: value
                };

                log(`MODBUS TCP ‚Üí ${MODBUS_HOST}:${MODBUS_PORT} | FC:${functionCode} | Reg:${register} | Val:${value || 'READ'}`);

                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (response.ok) {
                    const data = await response.json();
                    log(`MODBUS TCP ‚Üê Response: ${JSON.stringify(data)}`);
                    return data;
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                log(`‚ùå MODBUS TCP Error: ${error.message}`);
                document.getElementById('connection-status').innerHTML = '<span class="stopped">Connection Failed</span>';
                return null;
            }
        }

        async function readEngineData() {
            document.getElementById('connection-status').innerHTML = '<span class="warning">Reading MODBUS...</span>';
            
            try {
                // Read all registers via direct MODBUS TCP
                const statusResponse = await fetch(`http://${MODBUS_HOST}:8000/api/status`);
                if (statusResponse.ok) {
                    const data = await statusResponse.json();
                    
                    // Update displays
                    document.getElementById('rpm').textContent = data.engine.rpm || 0;
                    document.getElementById('temp').textContent = data.engine.temp || 0;
                    document.getElementById('fuel').textContent = (data.engine.fuel_flow || 0).toFixed(2);
                    document.getElementById('load').textContent = data.engine.load || 0;
                    
                    // Update status
                    const status = data.engine.status || 0;
                    const statusElement = document.getElementById('engine-status');
                    
                    if (status === 1) {
                        statusElement.textContent = 'RUNNING';
                        statusElement.className = 'running';
                    } else {
                        statusElement.textContent = 'STOPPED';
                        statusElement.className = 'stopped';
                    }
                    
                    document.getElementById('last-update').textContent = new Date().toLocaleTimeString();
                    document.getElementById('connection-status').innerHTML = '<span class="running">Connected (MODBUS TCP)</span>';
                    
                    log(`‚úì Engine Data: RPM=${data.engine.rpm} TEMP=${data.engine.temp} STATUS=${status}`);
                    
                    packetCount += 5; // Reading 5 registers
                    document.getElementById('packet-count').textContent = packetCount;
                }
            } catch (error) {
                log(`‚ùå Failed to read engine data: ${error.message}`);
                document.getElementById('connection-status').innerHTML = '<span class="stopped">Disconnected</span>';
            }
        }

        async function startEngine() {
            log('üöÄ SENDING START COMMAND VIA MODBUS TCP...');
            try {
                const response = await fetch(`http://${MODBUS_HOST}:8000/api/engine/start`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    log('‚úÖ START command sent successfully');
                    packetCount++;
                    document.getElementById('packet-count').textContent = packetCount;
                    setTimeout(readEngineData, 1000); // Read updated data
                } else {
                    log('‚ùå START command failed');
                }
            } catch (error) {
                log(`‚ùå START command error: ${error.message}`);
            }
        }

        async function stopEngine() {
            log('üõë SENDING EMERGENCY STOP VIA MODBUS TCP...');
            try {
                const response = await fetch(`http://${MODBUS_HOST}:8000/api/engine/stop`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    log('‚úÖ STOP command sent successfully');
                    packetCount++;
                    document.getElementById('packet-count').textContent = packetCount;
                    setTimeout(readEngineData, 1000); // Read updated data
                } else {
                    log('‚ùå STOP command failed');
                }
            } catch (error) {
                log(`‚ùå STOP command error: ${error.message}`);
            }
        }

        function togglePolling() {
            const button = document.getElementById('poll-btn');
            
            if (isPolling) {
                clearInterval(pollingInterval);
                pollingInterval = null;
                isPolling = false;
                button.textContent = 'START POLLING';
                log('‚èπÔ∏è Stopped MODBUS TCP polling');
            } else {
                pollingInterval = setInterval(readEngineData, 2000);
                isPolling = true;
                button.textContent = 'STOP POLLING';
                log('‚ñ∂Ô∏è Started MODBUS TCP polling (2s interval)');
                readEngineData(); // Read immediately
            }
        }

        // Initialize
        log('üîß Direct MODBUS TCP Monitor initialized');
        log(`üì° Target: ${MODBUS_HOST}:${MODBUS_PORT}`);
        log('üëÄ Monitor traffic with: wireshark filter "tcp.port == 5020"');
        
        // Auto-start polling after 2 seconds
        setTimeout(() => {
            log('üîÑ Auto-starting MODBUS TCP polling...');
            togglePolling();
        }, 2000);
    </script>
</body>
</html> 